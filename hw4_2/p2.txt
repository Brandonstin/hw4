// Write your answer to Problem 2 (b) and (c) here

For p2-1, the branch is taken if r1 is not equal to 0. r1 is initially stored with 4, r2 with 2 and r3 with 0. 
We then subtract r2 from 5 and store that result into r1 and then check if the branch is equal to 0. With a 
branch-not-taken philosophy, we immediately fetch the next instruction until the branch's condition is determined. 
In this case, we benefit from this since the branch isn't taken and our processor is able to continue carrying out 
the subsequent instructions at full speed.





(b) By using branch prediction, we can potentially save ourselves from needing to stall our flops. For either a branch-taken prediction or a not-taken prediction, 
we run the risk of needing to flush the instructions and wasting some clock cycles. However, if we do predict correctly, then we keep our CPI lower by not needing to stall with the only drawback being some clock cycles.

(c) No, branch prediction will not always take 1 cycle. In the case of BEQZ and likewise instructions, which require a register value to be read, we need to wait more than 1 cycle to determine if a branch will be taken.
